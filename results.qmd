# Results

```{r}
library(tidyverse)
library(leaflet)
library(leaflet.extras)
library(dplyr)
library(ggplot2)
library(ggmap)
library(lubridate)

data_crash <- readr::read_csv2("data/data_crash.csv")
holiday_data <- readr::read_csv("data/holidays.csv")
holiday_data$is_holiday <- "Yes"

```

## Spatial Representation
```{r}
# Sample the data so that we do not have too much data ploted on the map


# dt_sampled <-# sample_n(as.data.frame(data_crash), 4000) %>%
#   
#   # # filter(Hit_Run == 'Yes')
#   # filter(Number_of_Lanes == 19) %>%
#   #sample_n(4000)
#   filter(data_crash$Road_Name == top10)
dt_sampled <- data_crash %>%
  filter(Road_Name %in% top10)%>%
  sample_n(2000)

#dt_sampled <- sample_n(as.data.frame(data_crash), 4000)
  # rename(Hit_Run = 'Hit/Run') %>%
  # # filter(Hit_Run == 'Yes')
  # filter(Number_of_Lanes == 19) %>%




# Display the random sample
#print(dt_sampled)


```

```{r}
# Spatial data

# 
 leaflet(dt_sampled) %>%
#   addTiles() %>% 
#   addHeatmap(
#   lat = ~Latitude,
#   lng = ~Longitude,
#   blur = 15,  # Adjust the blur parameter
#   radius = 10)  # Adjust the radius parameter
  addMarkers(lng = ~Longitude, lat = ~Latitude, popup = "Marker")


```

<u>Comment :</u> We can see from the map multiple ouliers, all the crash data should be in the Montgomery County so every data outside of this area can be considered as outliers. Maybe when the localisation was added to the police report some numbers were mistaken.
*Should we remove all of them ?

## Time Series

```{r}

#dt_temporal <- data_crash[,]

dt_temporal <- dplyr::select(data_crash,c("Crash_Date_Time","Weather", "Hit_Run",
                       "First_Harmful_Event", "At_Fault"))

# dt_temporal <- left_join(dt_temporal, holiday_data, by = c("Crash_Date" = "date"))
# 
# dt_temporal <- mutate(dt_temporal, is_holiday = ifelse(is.na(is_holiday), "No", is_holiday))



head(dt_temporal)
```


```{r}
#Separate time and Date

dt_temporal$"Crash_Date_Time" <- as.POSIXct(dt_temporal$"Crash_Date_Time", format = "%m/%d/%Y %I:%M:%S %p", tz = "America/New_York")

dt_temporal$Crash_Date <- as.Date(dt_temporal$"Crash_Date_Time", tz = "America/New_York")

#I have a problem with the hours it doesn't show up well
dt_temporal$Crash_Time <- format(dt_temporal$"Crash_Date_Time", "%H:%M:%S")
dt_temporal
#ggplot(dt_temporal, aes(x = as.factor(Crash_week))) +
       #stat_count() +
       #labs(title='Number of car crash per weeks')

```



### Preprocessing for the df_temporal
```{r}
### add some "date slicers" columns
dt_temporal$Week_day <- weekdays(dt_temporal$Crash_Date)
dt_temporal$Month <-  months(dt_temporal$Crash_Date)
dt_temporal$Year <-  year(dt_temporal$Crash_Date)
dt_temporal$first_day_of_month <- as.Date(format(dt_temporal$Crash_Date, "%Y-%m-01"))

library(hms)
dt_temporal$Crash_Time <- as_hms(dt_temporal$Crash_Time)
dt_temporal$Crash_Hour <- hour(dt_temporal$Crash_Time) #Crash hour


### Transform some colkumns to factors
dt_temporal <- mutate(dt_temporal, Week_day = factor(Week_day,
                                             levels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")))

dt_temporal$Month <- factor(dt_temporal$Month, 
                          levels = c("January", "February", "March", "April", "May", "June","July", "August", "September", "October", "November", "December"),)

### arrange the data by date
dt_temporal <- dt_temporal |> arrange(Crash_Date)

dt_temporal_month <- dt_temporal |> group_by(Month, first_day_of_month, Week_day) |> summarise(total_accidents = n())


dt_temporal_Year_month <- dt_temporal |> group_by(Year, Month, first_day_of_month, Week_day) |> summarise(total_accidents = n())


### create a ts object
first_date_in_data <- min(dt_temporal$first_day_of_month)
last_date_in_data <- max(dt_temporal$first_day_of_month)
```


```{r}
start_date = min(dt_temporal$Crash_Date)
end_date = max(dt_temporal$Crash_Date)

date_sequence <- seq(as.Date("2014-12-28"), end_date, by = "week")
dt_temporal$Crash_week <- cut(dt_temporal$Crash_Date, breaks = c(date_sequence, Inf), labels = as.factor(date_sequence), include.lowest = TRUE)

dt_temporal_red <- dt_temporal %>%
  filter(Crash_Date > as.Date("2013", format = '%Y')) %>%
  group_by(Crash_week) %>%
  mutate(Count_week = n()) %>%
  arrange(Crash_week)

#Create a new table to remove the iteration where there are multiple time the same combination for the columns Crash_week and Count_week.
dt_temporal_week <- dt_temporal_red %>%
  distinct(Crash_week, Count_week, .keep_all = TRUE)%>%
  mutate(Crash_week = as.Date(Crash_week, format = "%Y-%m-%d")) %>%
  mutate(Crash_month = month(Crash_week))
#   
#   mutate(is_holiday = ifelse(Week_with_holiday %in% weeks_with_holiday$Week_with_holiday, "Yes", is_holiday)) %>%
#   select(-Week_with_holiday)


ggplot(dt_temporal_week, aes(x = Crash_week, y = Count_week)) +
  geom_line(aes(group=1)) + #because we grouped earlier by Crash_week we need now to specify that we treat all the data as one group.
  geom_point() +
  labs(title='Number of car crash per weeks')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
# Set breaks to 1 month interval
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") 
  #scale_x_date(date_breaks = "1 month", date_labels = "%b %Y")  
```


```{r}


# Create a new column for the week of the year
# Step 1: Create a data frame with all days in the year
all_days <- data.frame(date = seq(min(dt_temporal$Crash_Date), max(dt_temporal$Crash_Date), by = "days"))

# Step 2: Merge the data frames based on the week
merged_df <- inner_join(all_days, holiday_data, by = "date")

# Step 3: Create a new column "Is_Holiday" based on the merging results
merged_df$is_holiday <- ifelse(!is.na(merged_df$is_holiday), "Yes", "No")
merged_dy_for_temporal_day <- merged_df

merged_df$first_day_of_week_new <- floor_date(merged_df$date, "week")
merged_df$weekday1 <- weekdays(merged_df$first_day_of_week)

result_df <- merged_df %>%
  group_by(first_day_of_week_new) %>%
  summarise(is_holiday = if ("Yes" %in% is_holiday) "Yes" else "No")


```


```{r}
dt_temporal_week <- left_join(dt_temporal_week, result_df, by = c("Crash_week" = "first_day_of_week_new"))

dt_temporal_week <- mutate(dt_temporal_week, is_holiday = ifelse(is.na(is_holiday), "No", is_holiday))


ggplot(dt_temporal_week, aes(x = Crash_week, y = Count_week)) +
  geom_line(aes(group=1)) + #because we grouped earlier by Crash_week we need now to specify that we treat all the data as one group.
  geom_point(aes(color = is_holiday)) +
  labs(title='Number of car crash per weeks')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
# Set breaks to 1 month interval
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") 
  #scale_x_date(date_breaks = "1 month", date_labels = "%b %Y")  

```

<u>Comment :</u> We can visualize thanks to the time series representation the Covid crisis which lead to a reduction of car accident in 2020 since less cars were on the roads. Since then, the average number of accidents is a bit lower than pre-covid.




## Show the same plot by days


```{r}

dt_temporal_day <- dt_temporal |> group_by(Year, Month, Crash_Date) |> summarise(total_crash = n())

dt_temporal_day <- left_join(dt_temporal_day, merged_dy_for_temporal_day, by = c("Crash_Date"= "date"))



ggplot(dt_temporal_day |> filter(Year == 2019), aes(x = Crash_Date, y = total_crash)) +
  geom_line(aes(group=1)) + #because we grouped earlier by Crash_Date we need now to specify that we treat all the data as one group.
  geom_point(aes(color = is_holiday)) +
  labs(title='Number of car crash per weeks')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
# Set breaks to 1 month interval
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") 
  #scale_x_date(date_breaks = "1 month", date_labels = "%b %Y")  

```


```{r}
dt_temporal_day |>  group_by(Year) %>%
  slice(which.max(total_crash))

a <- dt_temporal_day |> 
  group_by(Year) |>
  top_n(5, total_crash) #|> filter(Month %in% c("January"))
ggplot(a) +
  geom_point(aes(x=Crash_Date, y=total_crash)) +
  scale_y_continuous(limits = c(0,80)) +
  scale_x_date(date_labels = "%Y-%m-%d", date_breaks = "1 month")+
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))



a |> group_by(Month) |> summarise(count=n()) #count(Month)

#holiday_data




```


```{r}

dt_temporal_day <- mutate(dt_temporal_day,crash_day_no_year = format(Crash_Date, "%m-%d"))

Month_list <-  c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")

##################################### data for d3 - mean crash per day over years
c <- dt_temporal_day |> filter(Year!=2020 & Year<2023)|> group_by(Month, crash_day_no_year) |> summarise(total_crash = mean(total_crash)) |>  mutate(day_only = factor(substr(crash_day_no_year, 4, 5)))
write_csv(c, "data/mean_crash_per_day_over_years.csv")


###########################################################
### let's see how this graph should look like in d3:
b <- dt_temporal_day |> filter(Year!=2020 & Year<2023)|> filter(Month %in%Month_list[1:7]) |> group_by(Month, crash_day_no_year) |> summarise(total_crash = mean(total_crash)) |>  mutate(day_only = factor(substr(crash_day_no_year, 4, 5)))


# # Create the plot
# ggplot(b, aes(x = crash_day_no_year, y = total_crash, color = Month)) +
#   geom_point() +
#   facet_grid(~Month)+
#   labs(y = "Total Crash") 

  
# Create the plot
ggplot(b, aes(x = day_only, y = total_crash, color = Month, group=Month)) +
  geom_point() +
  geom_line(alpha = 0.6)+
  #facet_grid(Month~., scales = "free_x", space = "free_x") +
  labs(y = "Total Crash") 
  
  



# 
# ggplot(b) +
#   geom_point(aes(x=crash_day_no_year, y=total_crash)) +
#   scale_y_continuous(limits = c(0,80)) +
#   scale_x_date(date_labels = "%Y-%m-%d", date_breaks = "1 month")+
#     theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

```

    d => ({
            Month: parseInt(d.Month),
            crash_day_no_year: parseInt(d.crash_day_no_year),
            total_crash: parse
        })

```{r}
c


```



```{r}
ggplot(dt_temporal_day |> mutate(Year = as.factor(Year))) +
  geom_boxplot(aes(x=Year, y=total_crash))
```


```{r}
dt_temporal_day |>  group_by(Year) %>%
  summarise((mean(total_crash)))
```



```{r}
dt_temporal_day |>  group_by(Year) %>%
  slice(which.min(total_crash))
```



```{r}

ggplot(dt_temporal_day, aes(x = Crash_Date, y = total_crash)) +
  geom_line(aes(group=1)) + #because we grouped earlier by Crash_Date we need now to specify that we treat all the data as one group.
  geom_point(aes(color = is_holiday)) +
  labs(title='Number of car crash per weeks')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
# Set breaks to 1 month interval
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") 
  #scale_x_date(date_breaks = "1 month", date_labels = "%b %Y")
```




### Weather Condition

```{r}

dt_temporal <- dt_temporal %>%
  filter(!Weather %in% c("OTHER", "UNKNOWN")) %>%
  filter(!is.na(Weather))

dt_temporal <- dt_temporal %>%
  mutate(Weather = if_else(Weather %in% c("SNOW", "SLEET","BLOWING SNOW"), "SNOW", Weather)) %>%
  mutate(Weather = if_else(Weather %in% c("SEVERE WINDS", "WINTRY MIX", "BLOWING SAND, SOIL, DIRT"), "WIND", Weather))%>%
  mutate(Condition = if_else(Weather %in% c("CLEAR","CLOUDY"),"Good","Bad"))

color_scale <- c("RAINING" = "slateblue", "SNOW" = "whitesmoke", "CLOUDY" = "gray", "FOGGY" ="gray27", "WIND"="seagreen4", "CLEAR" ="skyblue")

dt_temporal$Weather <- reorder(dt_temporal$Weather, X= as.numeric(factor(dt_temporal$Weather,levels = c('CLEAR','CLOUDY','FOGGY','WIND','SNOW','RAINING'))))

ggplot(dt_temporal, aes(x = Condition, fill = Weather)) +
  geom_bar() +
  scale_fill_manual(values = color_scale)

 


#ggplot(dt_temporal, aes(x= Weather))+
#geom_bar()
```

<u>Comment :</u> One can see an asymmetry between the bad and good conditions. It seems that bad conditions does not necessarily imply a higher number of accidents. However to be sure about that we need to have the proportion of the number of days where the road conditions were good or not.


### Hours of the day


```{r}
# we only care about the hours not the minutes
dt_temporal <- dt_temporal %>%
  mutate(Crash_Time = paste0(substr(Crash_Time, start = 1, stop =2),'h')) 


ggplot(dt_temporal, aes(x=Crash_Time))+
  geom_bar()+
  labs(x = 'Hours in the day',y = 'Number of Crash')
```
<u>Comment :</u> One can see that crash accidents occur more during the commute time especially the way back home between 15h to 17h.

### Type of Lane





## Roy
################ Roy

```{r}
data_crash |> head()
```



```{r}
ggplot(dt_temporal_month) +
  geom_boxplot(mapping=aes(x=Month, y=total_accidents))



library(ggridges)

### Distribution of total number of accidents by month
ggplot(dt_temporal_month) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Month)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Month), alpha = 0.5) +
  theme_minimal() +
  labs(title = "Distribution of total number of accidents by month")


#Distribution of total number of accidents by Day of week
ggplot(dt_temporal_month) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Week_day)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Week_day), alpha = 0.5) +
  theme_minimal() +
  labs(title = "Distribution of total number of accidents by weekday")


```

```{r}

library(ggridges)
library(patchwork)

dt_temporal_1 <- dt_temporal
# Convert the Month column to display the abbreviation version
# Create a list of month abbreviations
month_abbreviations <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
weekday_labels <- c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")

# Convert the Week_day column to display the abbreviation version
dt_temporal_1$Week_day <- ifelse(dt_temporal_1$Week_day == "Sunday", "Sun",
                             ifelse(dt_temporal_1$Week_day == "Monday", "Mon",
                             ifelse(dt_temporal_1$Week_day == "Tuesday", "Tue",
                             ifelse(dt_temporal_1$Week_day == "Wednesday", "Wed",
                             ifelse(dt_temporal_1$Week_day == "Thursday", "Thu",
                             ifelse(dt_temporal_1$Week_day == "Friday", "Fri",
                             ifelse(dt_temporal_1$Week_day == "Saturday", "Sat", dt_temporal_1$Week_day)))))))

dt_temporal_1$Week_day <- factor(dt_temporal_1$Week_day , levels = weekday_labels)

# Convert the Month column to display the abbreviation version
dt_temporal_1$Month <- ifelse(dt_temporal_1$Month == "January", "Jan",
                          ifelse(dt_temporal_1$Month == "February", "Feb",
                          ifelse(dt_temporal_1$Month == "March", "Mar",
                          ifelse(dt_temporal_1$Month == "April", "Apr",
                          ifelse(dt_temporal_1$Month == "May", "May",
                          ifelse(dt_temporal_1$Month == "June", "Jun",
                          ifelse(dt_temporal_1$Month == "July", "Jul",
                          ifelse(dt_temporal_1$Month == "August", "Aug",
                          ifelse(dt_temporal_1$Month == "September", "Sep",
                          ifelse(dt_temporal_1$Month == "October", "Oct",
                          ifelse(dt_temporal_1$Month == "November", "Nov",
                          ifelse(dt_temporal_1$Month == "December", "Dec", dt_temporal_1$Month))))))))))))

dt_temporal_1$Month <- factor(dt_temporal_1$Month, levels = month_abbreviations)

dt_temporal_month <- dt_temporal_1 |> group_by(Month, first_day_of_month, Week_day) |> summarise(total_accidents = n())

dt_temporal_hour <- dt_temporal_1 |> group_by(Month, first_day_of_month, Crash_Hour) |> summarise(total_accidents = n())


# Distribution of total number of accidents by month (the total number of accidents is with the total within in Year-Month combination)
plot_month <- ggplot(dt_temporal_month |> mutate(Month = as.factor(Month))) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Month)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Month), alpha = 0.5) +
  theme_minimal() +
  labs(subtitle = "By month")

# Distribution of total number of accidents by Day of week (the total number of accidents is with the total within in Year-Month combination)
plot_weekday <- ggplot(dt_temporal_month) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Week_day)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Week_day), alpha = 0.5) +
  theme_minimal() +
  labs(subtitle = "By weekday")


# Distribution of total number of accidents by Hour (the total number of accidents is with the total within in Year-Month combination)

plot_hours <- ggplot(dt_temporal_hour |> mutate(Crash_Hour = as.factor(Crash_Hour))) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Crash_Hour)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Crash_Hour), alpha = 0.5) +
  theme_minimal() +
  labs(subtitle = "By weekday")



# Combine the plots side by side
# combined_plots <- plot_month + plot_weekday + plot_hours

# Combine the plots side by side with one common title
combined_plots <- plot_month + plot_weekday + plot_hours +
  plot_layout(ncol = 2, heights = c(2, 2)) +
  plot_annotation(title = "Distribution of total number of accidents")


# Print the combined plots
print(combined_plots)

```

+ By combining histograms and density plots, we gain valuable insights into the distribution of total accidents aggregated by months per year, examining variations across different months, weekdays, and day-hours


+ **Number of accidents per month**:
Analyzing the density plots reveals a similar distribution in the total number of accidents across different months. However, delving into boxplots exposes distinct variances; for instance, the interquartile range (IQR) for January is significantly wider than that of February.


+ **Number of accidents per weekday**:
The density plots unveil noticeable differences in the distribution of total accidents between weekends and weekdays, providing insights into the varying patterns throughout the week.




+ **Number of accidents per Hour in day**:
Exploring the density plots illustrates significant disparities in the distribution of total accidents across different times of the day. Notably, there is typically an increase in accidents during the middle of the day, aligning with the expected higher traffic volumes during those hours.







### Time-plot displaying the total number of accidents trend over the years faceted by weekdays

```{r}

# ggplot(dt_temporal_Year_month, aes(x=first_day_of_month, y=total_accidents)) + 
#   geom_line() + 
#   geom_point() + 
#   facet_grid(Week_day~.)

# Filter data for December
december_data <- dt_temporal_Year_month %>%
  filter(month(first_day_of_month) == 12)

highest_points <- dt_temporal_Year_month %>%
  group_by(Year, Week_day) %>%
  slice_max(order_by = total_accidents)

ggplot(dt_temporal_Year_month, aes(x=first_day_of_month, y=total_accidents)) + 
  geom_line() + 
  stat_smooth(method = "loess", span=0.63, col = "blue", size = 1, se = FALSE) +  # Add a moving average line
  geom_point(data = highest_points, col = "black", size = 1.4) +  # Add points only for Jan
  facet_grid(~Week_day) +
  labs(title = "line plot of total accidents faceted by weekday",
       subtitle = "The black dots present for each year the month with \nthe highest number of accidents")

```

+ In the faceted line graph, a consistent trend is apparent in the number of accidents per weekday, suggesting a similar pattern across the week. However, the magnitude of accidents varies, with fewer incidents occurring on weekends, which aligns with expectations. Notably, the middle of the week appears to experience a higher frequency of accidents.

+ Furthermore, an examination of the "black dots," representing each year's month with the highest number of accidents, provides additional insights. Comparing these dots across different weekdays reveals distinctions, and an intriguing observation emerges when connecting these dots. If we were to draw a line connecting each black dot, a trend similar to the loess blue line trend in the plot becomes evident, indicating a potential overarching pattern in the occurrence of maximum accidents over the years.




### Hit/run

```{r}
dt_temporal_Year_month_hit_run <- dt_temporal |> group_by(Year, Month, first_day_of_month, Week_day, Hit_Run) |> summarise(total_accidents = n())

dt_temporal_Year_month_hit_run <- dt_temporal |> group_by(Year, Month, first_day_of_month, Week_day, Hit_Run) |> summarise(total_accidents = n())

# ggplot(dt_temporal_Year_month_hit_run, aes(x=first_day_of_month, y=total_accidents)) + 
#   geom_line() + 
#   stat_smooth(method = "loess", span=0.63, col = "blue", size = 1, se = FALSE) +  # Add a moving average line
#   facet_grid(~Hit_Run) +
#   labs(title = "line plot of total accidents faceted by weekday",
#        subtitle = "The black dots present for each year the month with \nthe highest number of accidents")
```



group by --> sum up the number of accident with No and with Yes 
road

##Is it more likely to Hit and Run in a specific Month / Week day / Hour?

```{r}
library(patchwork)

# Filter out NA values for Hit_Run
filtered_data <- dt_temporal %>%
  filter(!is.na(Hit_Run))

# Abbreviate the Month and Weekday names
month_labels <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
weekday_labels <- c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")

# Create a bar plot for Month
plot_month <- ggplot(filtered_data) +
  geom_bar(aes(x = Month, fill = Hit_Run), position = "fill") +
  scale_fill_manual(values = c("No" = "tomato", "Yes" = "darkgreen")) +
  labs(title = "Proportion of Hit-Run Accidents",
       subtitle = "Per Month of Year",
       x = "Month",
       y = "Proportion") +
  scale_x_discrete(labels = month_labels) +  # Abbreviate Month names
  theme_minimal() +
  theme(legend.position = "none")  # Remove the legend

# Create a bar plot for Weekday
plot_weekday <- ggplot(filtered_data) +
  geom_bar(aes(x = Week_day, fill = Hit_Run), position = "fill") +
  scale_fill_manual(values = c("No" = "tomato", "Yes" = "darkgreen")) +
  labs(title = "Proportion of Hit-Run Accidents",
       subtitle = "Per Weekday",
       x = "Weekday",
       y = "Proportion") +
  scale_x_discrete(labels = weekday_labels) +  # Abbreviate Weekday names
  theme_minimal()

# Arrange the two plots side by side
combined_plot <- plot_month + plot_weekday

# Print the combined plot
print(combined_plot)



### Plot Hit-Run by hours
### divide the crash hour into groups
dt_temporal$Crash_Hour_Group <- cut(dt_temporal$Crash_Hour,
  breaks = c(0, 4, 8, 12, 16, 20, 24),
  labels = c("0-4", "4-8", "8-12", "12-16", "16-20", "20-24"),
  include.lowest = TRUE
)


ggplot(dt_temporal %>%
         filter(!is.na(Hit_Run))) +
  geom_bar(aes(x = Crash_Hour_Group, fill = Hit_Run), position = "fill") +
  labs(title = "Proportion of Hit and Run Incidents by Crash Hour",
       x = "Crash Hour",
       y = "Proportion") +
  scale_fill_manual(values = c("No" = "tomato", "Yes" = "darkgreen")) +  # Customize colors if needed
  theme_minimal()

```
+ There doesn't appear to be a correlation between the month and Hit-Run incidents; in other words, there isn't a particular month with a higher likelihood of a Hit-Run accident.
+ However, we observe a higher proportion of Hit-Run incidents during weekends (Saturday and Sunday) compared to the proportions on other weekdays.

+ Concerning the Hit-Run proportion per hour—there is an observed escalation in the proportion of Hit-Run accidents during late hours. Furthermore, there seems to be a consistent "linear trend" in Hit-Run incidents as the day unfolds.



### First_Harmful_Event

```{r}
#count(dt_temporal, First_Harmful_Event) |> arrange(desc(n))

### taking only the 7 top categories in  First_Harmful_Event
df_for_harmful_event <- dt_temporal %>%
  filter(!is.na(First_Harmful_Event)) %>%  # Remove NA values
  mutate(
    First_Harmful_Event = tolower(First_Harmful_Event),
    First_Harmful_Event = factor(First_Harmful_Event) %>% fct_lump(n = 7, other_level = "Other"))

###Mosaic plot 1:
mosaicplot(table(factor(df_for_harmful_event$First_Harmful_Event), df_for_harmful_event$Hit_Run), main= "Mosaic plot for Hit Run vs First Harmful Event",
           color = c('tomato', 'darkgreen'), 
           las = 2  # Rotate labels by 90 degrees
)

count(df_for_harmful_event, Hit_Run, First_Harmful_Event)


#+
 # scale_fill_manual(values = c("No" = "tomato", "Yes" = "darkgreen")) +

```
+ We can see that the first harmful event has a great connection / correlation to the Hit-Run variable --> there are great variations between the proportion of Hit-Run vs. Not Hit-Run accidents given the different `First_Harmful_Event` categories.

+ Note that for "Parked-Vehicle" the proportion of Hit-Run is 0.45 which is more than twice as big as the overall Hit-Run proportion (0.18):

```{r}
dt_temporal |> count(Hit_Run) |> mutate("prop" = n/nrow(dt_temporal))
a <- dt_temporal |> filter(grepl(c("Parked"), First_Harmful_Event, ignore.case = T)) |> count(Hit_Run, First_Harmful_Event) 
a|> mutate("prop" = n/sum(a$n)) 

```


## Weather

```{r}

df_mosaic_by_weather <- dt_temporal |> group_by(Weather, Hit_Run) |> summarise(Freq = n())


###Mosaic plot 1:
mosaicplot(table(dt_temporal$Weather, dt_temporal$Hit_Run), main= "Mosaic plot for Hit Run vs First Harmful Event",
           color = c('tomato', 'darkgreen'), 
           las = 2  # Rotate labels by 90 degrees
)


vcd:: mosaic(Hit_Run ~ Weather,
 data = df_mosaic_by_weather,
 direction = c("v", "h"), 
 highlighting_fill=c('tomato','darkgreen'))
```


## Things we found from graphs we created"
+ We checked and there doesn't seem to be a correlation between the `Weather` and the `Hit_Run`




```{r}
dt_temporal_week


ts_data <- ts(data = dt_temporal_week$Crash_week, start = c(2015,1,3), end = c(2023,11,13), frequency = 51)

#dt_temporal_week$Crash_Date[nrow(dt_temporal_week)]


# 
# ts_data<- ts(df_temporal_week$Crash_week)
# plot(decompose())


```



Box plot 
x axis - day of week
the box itself will use the number of accidents




# Ethan Part

```{r}
## Explore the Categorical data we have

dt_lane <- data_crash[,c("Hit_Run","Route_Type","Number_of_Lanes","NonTraffic","Road_Grade","At_Fault","Cross_Street_Type","Collision_Type","Traffic_Control","Driver_Substance_Abuse","Road_Alignment","Junction","Road_Condition","Road_Division","First_Harmful_Event","Light","Surface_Condition")]

unique_values <- lapply(dt_lane, unique)

# Print unique value for each of the column
for (col_name in names(unique_values)) {
  cat("Column:", col_name, "\n")
  print(unique_values[[col_name]])
  cat("\n")
}

```

```{r}
dt_intersection <- data_crash %>%
   mutate(Traffic_Control = recode(Traffic_Control,
        "FLASHING TRAFFIC SIGNAL" = "Traffic Light",
        "TRAFFIC SIGNAL" = "Traffic Light",
        "NO CONTROLS" = 'No Controls',
        "RAILWAY CROSSING DEVICE	" = 'Warning Sign',
        "WARNING SIGN" = 'Warning Sign',
        "SCHOOL ZONE SIGN DEVICE" = 'Warning Sign',
        "YIELD SIGN" = 'Warning Sign',
        "STOP SIGN" = 'Stop Sign',
        .default  = 'Other')) %>%
  filter(!is.na(Traffic_Control))
```

```{r}
## Create 2 new datasets to explore different Categorical values
dt_lane <- data_crash[,c("Road_Division", "Junction", "Road_Alignment" ,"Traffic_Control","Road_Name","Number_of_Lanes","Hit_Run")]

dt_responsible <- data_crash[,c("Hit_Run","NonTraffic","At_Fault","Driver_Substance_Abuse")]

```

```{r}
#Rename the column in Road_type and get rid of the Na and the unknown values
dt_lane <- dt_lane %>%
  mutate(Road_Division = recode(Road_Division,
        "TWO-WAY, NOT DIVIDED WITH A CONTINUOUS LEFT TURN" = "2-way, not divided",
        "TWO-WAY, NOT DIVIDED" = "2-way, not divided",
        "TWO-WAY, DIVIDED, POSITIVE MEDIAN BARRIER" = '2-way, divided',
        "TWO-WAY, DIVIDED, UNPROTECTED PAINTED MIN 4 FEET" = '2-way, divided',
        "ONE-WAY TRAFFICWAY" = '1-way',
        "OTHER" = 'Other')) %>%
  filter(Road_Division != 'UNKNOWN') %>%
  filter(Road_Division != 'Other') %>%
  na.omit()

#Change the column Number of Lanes to remove the lanes with more than 6 lanes
dt_lane <- dt_lane %>%
  filter(Number_of_Lanes < 7) %>%
  filter(Number_of_Lanes != 0)
  
# Change the order of factor 
dt_lane$Road_Division <- factor(dt_lane$Road_Division, levels = c("1-way", "2-way, not divided", "2-way, divided", 'Other'))

## This plot is less good and will most likely be deleted
# ggplot(dt_lane, aes(x=Road_Division))+
#   geom_bar() +
#   facet_wrap(~Number_of_Lanes)+
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(dt_lane, aes(y=Road_Division))+
  geom_bar() +
  facet_grid(Number_of_Lanes~.)+
  #theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title ='Facet by number of Lanes' )
```
<u>Comment :</u> One can see that most of the accidents that happends on 3 lanes road are 2-way and divided (most likely highway). 

### Junction


```{r}
dt_lane <- dt_lane %>%
  mutate(Junction = recode(Junction,
        "INTERSECTION" = "Intersection",
        "INTERSECTION RELATED" = "Intersection",
        "NON INTERSECTION" = 'Non Intersection',
        "OTHER DRIVEWAY" = 'Driveway',
        "COMMERCIAL DRIVEWAY" = 'Driveway',
        "ALLEY" = 'Driveway',
        "CROSSOVER RELATED" = "Crossover",
        "INTERCHANGE RELATED" = "Interchange",
        "RESIDENTIAL DRIVEWAY" = 'Driveway',
        "RAILWAY GRADE CROSSING"= 'Other',
        "OTHER" = 'Other')) %>%
  filter(Junction != 'UNKNOWN') %>%
  filter(Junction != 'Other') %>%
  na.omit() 

lane_freq <- dt_lane %>%
  count(Junction, name = "Frequency_junc")
dt_lane <- left_join(lane_freq, dt_lane, by = "Junction")

ggplot(dt_lane, aes(x = reorder(Junction, -Frequency_junc))) +
  geom_bar() +
  labs(title = "Bar Plot of Junction Types with Count", x = "Junction Type", y = "Count") +
  theme_minimal()  # Adjust the theme if needed
```
### Traffic Control

```{r}
dt_lane <- dt_lane %>%
   mutate(Traffic_Control = recode(Traffic_Control,
        "FLASHING TRAFFIC SIGNAL" = "Traffic Light",
        "TRAFFIC SIGNAL" = "Traffic Light",
        "NO CONTROLS" = 'No Controls',
        "RAILWAY CROSSING DEVICE	" = 'Warning Sign',
        "WARNING SIGN" = 'Warning Sign',
        "SCHOOL ZONE SIGN DEVICE" = 'Warning Sign',
        "YIELD SIGN" = 'Warning Sign',
        "STOP SIGN" = 'Stop Sign',
        .default  = 'Other')) %>%
  filter(!is.na(Traffic_Control))

lane_freq <- dt_lane %>%
  count(Traffic_Control, name = "Frequency_control")
dt_lane <- left_join(lane_freq, dt_lane, by = "Traffic_Control")
  
ggplot(dt_lane, aes(x = reorder(Traffic_Control, -Frequency_control))) +
  geom_bar() +
  labs(title = "Bar Plot of Junction Types with Count", x = "Junction Type", y = "Count") +
  theme_minimal()  # Adjust the theme if needed
```
### Proportion of the unique roads by type (where there have been an accident)

```{r}
Nbroads = n_distinct(data_crash$Road_Name)
#print(Nbroads)
#count(dt_lane, Number_of_Lanes)

road_counts <- dt_lane %>%
  group_by(Road_Division) %>%
  summarise(Unique_Roads = n_distinct(Road_Name)) %>%
  mutate(Proportion = 100 * Unique_Roads / sum(Unique_Roads))


print(road_counts)
```

### Alluvial plot to see pattern

```{r}

dt_lane1 <- dt_lane[,c('Road_Division', 'Junction', 'Traffic_Control','Road_Name','Hit_Run')]

n_threshold = 100 
dt_lane1 <- dt_lane1 %>%
  group_by(Road_Division, Junction, Traffic_Control) %>%
  mutate(Frequency = n()) %>%
  ungroup() %>%
  filter(Frequency >= n_threshold) %>%
  distinct(Road_Division, Junction, Traffic_Control, .keep_all = TRUE)

# Map_pt <- dt_lane1$Road_Name
# Map_pt
```

```{r}
library(ggalluvial)

junction_order <- c("Crossover", "Intersection", "Driveway","Non Intersection", "Interchange")

# Reorder the Junction variable in the dataset
dt_lane1 <- dt_lane1 %>%
  mutate(Junction = factor(Junction, levels = junction_order))

# Plot the alluvial diagram

ggplot(data = dt_lane1,
       aes(axis1 = Road_Division, axis2 = Traffic_Control, axis3 = Junction, axis4= Hit_Run, y = Frequency)) +
  geom_alluvium(aes(fill = Hit_Run)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  #scale_x_discrete(limits = c("Road Division", "Traffic Signal", "Junction type"),
                   #expand = c(0.15, 0.05, 0.05)) +
  theme_void()
```

## Speaking about Roads, where are we ?

```{r}
dt_lane2 <- dt_lane %>%
  group_by(Road_Name) %>%
  mutate(Frequency_road = n()) %>%
  ungroup() %>%
  #filter(Frequency >= n_threshold) %>%
  distinct(Road_Name, .keep_all = TRUE)

top_10_roads <- dt_lane2 %>%
  arrange(desc(Frequency_road)) %>%  # Arrange by Frequency in descending order
  slice_head(n = 10) %>%       # Select the top 10 rows
  select(Road_Name,Frequency_road) %>%
  as.list()

top10 <- top_10_roads$Road_Name
top10
```








## Who's at Fault ?


```{r}
dt_responsible <- dt_responsible %>%
  mutate(Driver_Substance_Abuse = str_extract(Driver_Substance_Abuse, "^[^,]+")) %>%
  mutate(Driver_Substance_Abuse = recode(Driver_Substance_Abuse,
    "ALCOHOL CONTRIBUTED" ="alcohol",
    "ALCOHOL PRESENT" = "alcohol",
    "COMBINATION CONTRIBUTED" = "combined substance",
    "COMBINED SUBSTANCE PRESENT" = "combined substance",
    "ILLEGAL DRUG CONTRIBUTED" = "illegal drug",
    "ILLEGAL DRUG PRESENT" = "illegal drug",
    "MEDICATION CONTRIBUTED" = "under medication",
    "MEDICATION PRESENT" = "under medication",
    "UNKNOWN" = 'unknown',
    "OTHER" = 'unknown',
    "NONE DETECTED" = 'none detected'
  )) %>%
  filter(Driver_Substance_Abuse != "N/A")

count(dt_responsible,Driver_Substance_Abuse)

#redav::plot_missing(dt_responsible) # We see that more than 80% of the rows does not have Na so I will drop all the Na

dt_responsible <- dt_responsible %>%
  na.omit() %>%
  filter(Driver_Substance_Abuse != 'none detected') # %>% # remove the none detected because they are too much
  # filter(Driver_Substance_Abuse != 'alcohol') %>%
  # filter(Driver_Substance_Abuse != 'unknown')

responsible_freq <- dt_responsible %>%
  count(Driver_Substance_Abuse, name = "Frequency_drug")
dt_responsible <- left_join(responsible_freq, dt_responsible, by = "Driver_Substance_Abuse")
  
ggplot(dt_responsible, aes(x = reorder(Driver_Substance_Abuse, -Frequency_drug))) +
  geom_bar() +
  labs(title = "Bar Plot of Junction Types with Count", x = "Junction Type", y = "Count") +
  theme_minimal()  # Adjust the theme if needed
```

```{r}
library(gridExtra)
count(dt_responsible, Driver_Substance_Abuse)
dt_responsible <- dt_responsible %>%
  mutate(
    Driver_Substance_Abuse_A = if_else(Driver_Substance_Abuse %in% c('alcohol', 'unknown'), Driver_Substance_Abuse, NA_character_),
    Driver_Substance_Abuse_B = if_else(!Driver_Substance_Abuse %in% c('alcohol', 'unknown'), Driver_Substance_Abuse, NA_character_)
  )



mp1 <- vcd:: mosaic(Hit_Run ~  Driver_Substance_Abuse_A + NonTraffic,
 data = dt_responsible,
 direction = c("v", "v","h" ),
 axes_labels = c('Driver Substance Abuse', 'Traffic'))

mp2 <- vcd:: mosaic(Hit_Run ~  Driver_Substance_Abuse_B + NonTraffic,
 data = dt_responsible,
 direction = c("v", "v","h" ),
 axes_labels = c('Driver Substance Abuse', 'Traffic'))



```
There is more Hit and Run instance when there is no traffic (yes instance for the column NonTraffic) most likely due to the fact that it is easier to go away without traffic on the road.




<u>Comment :</u> One can see that crash accidents occur more during the commute time escpecially the way back home between 15h to 17h.





