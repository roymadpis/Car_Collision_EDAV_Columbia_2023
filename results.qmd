# Results

```{r, warning = FALSE, message=FALSE}
#Loading libraries and the data
library(tidyverse)
library(dplyr)
library(ggplot2)
library(lubridate)

library(hms)

library(ggridges)
library(patchwork)
library(ggalluvial)

#for the spatial data part
library(leaflet)
library(leaflet.extras)
library(ggmap)
library(sf) 


#loading the pre-processed car-crash data
data_crash <- readr::read_csv2("data/data_crash.csv")

#loading the holiday data
#holiday_data <- readr::read_csv("data/holiday_US.csv")

holiday_data <- readr::read_csv("data/holiday_dates.csv")
holiday_data <- holiday_data |> filter(countryOrRegion == "United States") |> select(c(normalizeHolidayName,isPaidTimeOff, date)) 

holiday_data$is_holiday <- "Yes"
holiday_data <- holiday_data |> rename("Holiday" = "normalizeHolidayName")


```

```{r, echo=FALSE, results='hide'}
# Set the local time to english to get the days in English (same for the month)
Sys.setlocale("LC_TIME", "English")
```


## Part 1 - Time Series Analysis
We begin our analysis with time-series analysis. In order to perform this examination, we take the date-time column `Crash_Date_Time` and extract from it the date, Year, Month, weekday, time, hour, etc. of the accident. Then we aggregate the data according to one or more of the date-time new columns to get the total number of accident within that time-frame. Finally we observe the time-series of the number of accident with respect to a given date/time dimension.

We understood there could be some special meaningful factor explaining the values observed for some days during the year - those are for example the holidays in the american calendar. We assume the number of car accident might be influenced by the presence of holidays ( maybe more/less people will drive and/or people might be more likely to drink and drive or act in a more dangerous/safe manner)

To get the dates of these holidays we used a dataset from Microsoft Azure that we downloaded using Python [Visit Microsoft Azure Open Datasets](https://learn.microsoft.com/en-us/azure/open-datasets/dataset-public-holidays?tabs=azureml-opendatasets){.class-to-style-as-link}.
We filter the relevant rows for our study (took dates between 2015 and 2023) 


### Preprocess the Date-Time column

Here we take the date/time column and transform it into the right data type as well as create some distinct date/time columns that will help us investigate and explore the data (time series analysis)




```{r, message=FALSE}
dt_temporal <- dplyr::select(data_crash,c("Crash_Date_Time","Weather", "Hit_Run",
                       "First_Harmful_Event", "At_Fault"))

#Separate time and Date
dt_temporal$"Crash_Date_Time" <- as.POSIXct(dt_temporal$"Crash_Date_Time", format = "%m/%d/%Y %I:%M:%S %p", tz = "America/New_York")

dt_temporal$Crash_Date <- as.Date(dt_temporal$"Crash_Date_Time", tz = "America/New_York")

dt_temporal$Crash_Time <- format(dt_temporal$"Crash_Date_Time", "%H:%M:%S")
dt_temporal$Crash_Time <- as_hms(dt_temporal$Crash_Time)
dt_temporal$Crash_Hour <- hour(dt_temporal$Crash_Time) #Crash hour


### add some "date slicers" columns
dt_temporal$Week_day <- weekdays(dt_temporal$Crash_Date)
dt_temporal$Month <-  months(dt_temporal$Crash_Date)
dt_temporal$Year <-  year(dt_temporal$Crash_Date)
dt_temporal$first_day_of_month <- as.Date(format(dt_temporal$Crash_Date, "%Y-%m-01"))


### Transform some columns to factors --> for visualization purpose
dt_temporal <- mutate(dt_temporal, Week_day = factor(Week_day,
                                                     levels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")))

dt_temporal <- mutate(dt_temporal, Month = factor(Month,
                                                     levels = c("January", "February", "March", "April", "May", "June","July", "August", "September", "October", "November", "December")))

# dt_temporal$Month <- factor(dt_temporal$Month, 
#                           levels = c("January", "February", "March", "April", "May", "June","July", "August", "September", "October", "November", "December"),)

### arrange the data by date
dt_temporal <- dt_temporal |> arrange(Crash_Date)

dt_temporal_month <- dt_temporal |> group_by(Month, first_day_of_month, Week_day) |> summarise(total_accidents = n())

dt_temporal_Year_month <- dt_temporal |> group_by(Year, Month, first_day_of_month, Week_day) |> summarise(total_accidents = n())

# Getting the first and last date in the data
start_date = min(dt_temporal$Crash_Date)
end_date = max(dt_temporal$Crash_Date)

### Filtering the holiday dates

holiday_data <- holiday_data |> filter(date >= start_date & date <= end_date)


```

### Create Weekly car-accident data

We wish to analyze the **weekly** trends of the total number of car accidents in Montgomery county. In order to do so, we group the data by weeks and sum the number of accidents.
Then we aggregate the data again by **Month** to have the average weekly car accidents for every year-month combination. We plot this as a black line.
At the same time we plot a time series line plot for each holiday-day category --> that is, every holiday has a line + points representing the total number of accidents that happened in the **week** of that holiday.
Finally we can use the graph to compare between the total number of accidents in the different weeks of the years and see if a given holiday is able to "increase" or "decrease" the total number of accidents in the week it was celebrated at.

```{r}
date_sequence <- seq(as.Date("2014-12-28"), end_date, by = "week")
dt_temporal$Crash_week <- cut(dt_temporal$Crash_Date, breaks = c(date_sequence, Inf), labels = as.factor(date_sequence), include.lowest = TRUE)

dt_temporal_red <- dt_temporal %>%
  filter(Crash_Date > as.Date("2013", format = '%Y')) %>%
  group_by(Crash_week) %>%
  mutate(Count_week = n()) %>%
  arrange(Crash_week)

#Create a new table to remove the iteration where there are multiple time the same combination for the columns Crash_week and Count_week.
dt_temporal_week <- dt_temporal_red %>%
  distinct(Crash_week, Count_week, .keep_all = TRUE)%>%
  mutate(Crash_week = as.Date(Crash_week, format = "%Y-%m-%d")) %>%
  mutate(Crash_month = month(Crash_week))

### The first and last week in the data aren't complete - they include less than 7 days, so we wish to remove them from the  plot
dt_temporal_week_without_first_last_week <- filter(dt_temporal_week, Crash_week!=dt_temporal_week$Crash_week[1] & Crash_week!=dt_temporal_week$Crash_week[nrow(dt_temporal_week)])


```


```{r}
# Create a new column for the week of the year
# Step 1: Create a data frame with all days in the year
all_days <- data.frame(date = seq(min(dt_temporal$Crash_Date), max(dt_temporal$Crash_Date), by = "days"))

# Step 2: Merge the data frames based on the week
merged_df <- inner_join(all_days, holiday_data, by = "date")

# Step 3: Create a new column "Is_Holiday" based on the merging results
merged_df$is_holiday <- ifelse(!is.na(merged_df$is_holiday), "Yes", "No")
merged_dy_for_temporal_day <- merged_df

merged_df$first_day_of_week_new <- floor_date(merged_df$date, "week")
merged_df$weekday1 <- weekdays(merged_df$first_day_of_week)

result_df <- merged_df %>%
  group_by(first_day_of_week_new) %>%
  summarise(is_holiday = if ("Yes" %in% is_holiday) "Yes" else "No",
            holiday= first(Holiday))

```

We display here a time-series graph describing the total number of accidents per week from 2015 to 2023. 

```{r, message=FALSE, warning=FALSE}
dt_temporal_week <- left_join(dt_temporal_week_without_first_last_week, result_df, by = c("Crash_week" = "first_day_of_week_new"))

dt_temporal_week <- mutate(dt_temporal_week, is_holiday = ifelse(is.na(is_holiday), "No", is_holiday))

dt_temporal_week_only_holiday <- dt_temporal_week |> filter(is_holiday == "Yes")

####################################
dt_temporal_week_average_by_month <- dt_temporal_week |> group_by(Year, Month) |>
  summarise(Count_week = mean(Count_week),
            Crash_week = min(Crash_week),
            holiday = "mean_month")

data_for_plot <- rbind(dt_temporal_week_only_holiday|> select(Year, Month, Crash_week, Count_week, holiday),
      dt_temporal_week_average_by_month)


ggplot(data_for_plot |> filter(holiday != "mean_month"), ) +
  geom_line(aes(group=holiday, x = Crash_week, y = Count_week, color = holiday), size = 0.4)+
      geom_point(aes(color = holiday,x = Crash_week, y = Count_week)) +
  geom_line(data = data_for_plot|> filter(holiday=="mean_month"),aes(x = Crash_week, y = Count_week), size = 0.7) +
  labs(title = "Weekly Car accidents per holiday",
       subtitle = "The black line is an average of accidents per month",
       x = "Year", y="Total Accidents in a given week")
  
```


**Using the graph we can get some interesting insights :**

+ First, looking at the black line, which represents the average accidents over a period of month (over the years), we can see the car-accidents is a time-series with a decreasing trend (that can be attributed to the Covid-19 outbreak) and seasonality that we will explore later in this study.

+ About the holiday, the **Veterans Day** and **Columbus Day** tend to have higher amount of car accidents compared to the other holidays and compared to the average car accidents.

+ Surprisingly, the **Independence day** has relatively lower car accidents compared to the average car accidents.

+ Additionally, there is a noticeable decline in the number of car accidents observed between 2020 and 2021. This decrease can be attributed to the impact of the COVID-19 outbreak, which resulted in extensive lockdowns and a substantial reduction in the presence of drivers on the roads. Subsequent to this period, the average number of accidents has remained slightly lower than the pre-COVID levels.
It is worth noting that we generated box plots for each year, illustrating the total crashes per day. Due to space constraints, we won't present them here, but it is important to highlight our observations. For the years 2015 to 2019, the box plots exhibited remarkable similarity, indicating comparable sizes of the interquartile range (IQR), Q1, Q3, and median. However, the box plot for 2020 stood out as notably lower than the preceding years. Furthermore, the box plots for 2021 and beyond were lower than those before 2020 but higher than the values observed in 2020.


### Create daily car-accident data

Before displaying time-series graph of the **daily** car accidents, we wish to Plot **decomposition** graph for the daily time-series. The decomposition graph displays the different components of the daily number of accidents time-series.

```{r, message=FALSE}
dt_temporal_day <- dt_temporal |> group_by(Year, Month, Crash_Date) |> summarise(total_crash = n())

dt_temporal_day <- left_join(dt_temporal_day, merged_dy_for_temporal_day, by = c("Crash_Date"= "date"))

### ts daily data
ts_data <- ts(data = dt_temporal_day$total_crash, start = c(2015,1,3), end = c(2023,11,13), frequency = 365)
plot(decompose(ts_data))
```

The decomposition graph for the daily number of accidents time series, **reveals there is a clear seasonality in the accidents data**, that is - there are some cyclical patterns.


### Average number of car accidents per day of month over the years

```{r, message=FALSE}
dt_temporal_day <- mutate(dt_temporal_day,crash_day_no_year = format(Crash_Date, "%m-%d"))

Month_list <-  c("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December")

##################################### data for d3 - mean crash per day over years
c <- dt_temporal_day |> filter(Year!=2020 & Year<2023)|> group_by(Month, crash_day_no_year) |> summarise(total_crash = mean(total_crash)) |>  mutate(day_only = factor(substr(crash_day_no_year, 4, 5)))
write_csv(c, "data/mean_crash_per_day_over_years.csv")

###Data for D3
c |> filter(Month == "January") |> write_csv("data/data_for_d3/Jan_data.csv")
c |> filter(Month == "February") |> write_csv("data/data_for_d3/Feb_data.csv")
c |> filter(Month == "March") |> write_csv("data/data_for_d3/March_data.csv")
c |> filter(Month == "April") |> write_csv("data/data_for_d3/April_data.csv")
c |> filter(Month == "May") |> write_csv("data/data_for_d3/May_data.csv")
c |> filter(Month == "June") |> write_csv("data/data_for_d3/June_data.csv")
c |> filter(Month == "July") |> write_csv("data/data_for_d3/July_data.csv")
c |> filter(Month == "August") |> write_csv("data/data_for_d3/August_data.csv")
c |> filter(Month == "September") |> write_csv("data/data_for_d3/September_data.csv")
c |> filter(Month == "October") |> write_csv("data/data_for_d3/October_data.csv")
c |> filter(Month == "November") |> write_csv("data/data_for_d3/November_data.csv")
c |> filter(Month == "December") |> write_csv("data/data_for_d3/December_data.csv")

###########################################################
### let's see how this graph should look like in d3:
b <- dt_temporal_day |> filter(Year!=2020 & Year<2023)|> filter(Month %in%Month_list[1:12]) |> group_by(Month, crash_day_no_year) |> summarise(total_crash = mean(total_crash)) |>  mutate(day_only = factor(substr(crash_day_no_year, 4, 5)))
  
# Create the plot
ggplot(b, aes(x = day_only, y = total_crash, color = Month, group=Month)) +
  geom_point() +
  geom_line(size = 0.35)+
  #facet_grid(Month~., scales = "free_x", space = "free_x") +
  labs(title = "Average number of car accidents per Month over the years",
       subtitle = "Not including 2020 and 2023",
       x = "Day of Month", y = "Average number of car accidents") 


```


Average number of accidents per day of month over the years reveals a unique "trend" for each month. There are month with a higher average of accidents on specific days then others. For example, the 4th of July has typically lower values than the 4th of other months and similarly the 25th of December (Christmas) has on average less accidents. The 1st of Dec has, on average more accidents than the the 1st of the other months, it is quite surprising that the 1st of January, the "new-year" day has the lowest average car accidents compared to the other months, (Maybe there is higher police enforcement leading to this outcome?). In the same vein, the 2nd and 3rd of November and May tend to have, on average, more accidents than the 2nd and 3rd of other month.

**Note that We also plot this graph in `D3` - the power of D3 in this sense is to enable comparing different months easily. The above graph has too many months displayed all at once, and it could be hard to compare some specific months to each other.**



### Hours of the day
We would like to see the number of accidents per hour of day - are there any hours in the day that typically have more accidents than others?

```{r}
# we only care about the hours not the minutes
dt_temporal <- dt_temporal %>%
  mutate(Crash_Time = paste0(substr(Crash_Time, start = 1, stop =2),'h')) 

ggplot(dt_temporal, aes(x = Crash_Time)) +
  geom_bar(fill = "cornflowerblue", color = "black") +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5, size = 3) +  # Adjust size as needed
  labs(title = "Total number of accidents per day-hour",
       x = 'Hours in the day', y = 'Number of Crashes')
```
Car crash accidents tend to spike during the work commute hours, particularly between 15:00 to 17:00. This timeframe, associated with the journey back home, is notorious for having a higher number of car on the roads leading to an increased number of accidents. This visualization serves as a reminder for drivers to exercise extra caution on the road during the late afternoon and evening hours. Besides, the data reveals a significant increase in accidents during the afternoon compared to the morning. This pattern suggests that fatigue accumulated throughout the day might influence people's driving behavior. The increased number of accidents during the afternoon hours serves as a important observation, emphasizing the potential impact of daily tiredness on driving safety. Maybe the state should focus on encouraging workers to use public transportation or provide alternative options for a safe commute home when they feel tired from work. 


### Distribution of the number of accidents by different time-slicers: Month, weekday, hour
Let's explore more into detail the distribution of number of accidents per month, per weekday and per hour. Is there a difference in the distribution of accidents across months, weekdays, and hours?

```{r, message=FALSE, fig.height=10}

dt_temporal_1 <- dt_temporal
# Convert the Month column to display the abbreviation version
# Create a list of month abbreviations
month_abbreviations <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
weekday_labels <- c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")

# Convert the Week_day column to display the abbreviation version
dt_temporal_1$Week_day <- ifelse(dt_temporal_1$Week_day == "Sunday", "Sun",
                             ifelse(dt_temporal_1$Week_day == "Monday", "Mon",
                             ifelse(dt_temporal_1$Week_day == "Tuesday", "Tue",
                             ifelse(dt_temporal_1$Week_day == "Wednesday", "Wed",
                             ifelse(dt_temporal_1$Week_day == "Thursday", "Thu",
                             ifelse(dt_temporal_1$Week_day == "Friday", "Fri",
                             ifelse(dt_temporal_1$Week_day == "Saturday", "Sat", dt_temporal_1$Week_day)))))))

dt_temporal_1$Week_day <- factor(dt_temporal_1$Week_day , levels = weekday_labels)

# Convert the Month column to display the abbreviation version
dt_temporal_1$Month <- ifelse(dt_temporal_1$Month == "January", "Jan",
                          ifelse(dt_temporal_1$Month == "February", "Feb",
                          ifelse(dt_temporal_1$Month == "March", "Mar",
                          ifelse(dt_temporal_1$Month == "April", "Apr",
                          ifelse(dt_temporal_1$Month == "May", "May",
                          ifelse(dt_temporal_1$Month == "June", "Jun",
                          ifelse(dt_temporal_1$Month == "July", "Jul",
                          ifelse(dt_temporal_1$Month == "August", "Aug",
                          ifelse(dt_temporal_1$Month == "September", "Sep",
                          ifelse(dt_temporal_1$Month == "October", "Oct",
                          ifelse(dt_temporal_1$Month == "November", "Nov",
                          ifelse(dt_temporal_1$Month == "December", "Dec", dt_temporal_1$Month))))))))))))

dt_temporal_1$Month <- factor(dt_temporal_1$Month, levels = month_abbreviations)

dt_temporal_month <- dt_temporal_1 |> group_by(Month, first_day_of_month, Week_day) |> summarise(total_accidents = n())

dt_temporal_hour <- dt_temporal_1 |> group_by(Month, first_day_of_month, Crash_Hour) |> summarise(total_accidents = n())


# Distribution of total number of accidents by month (the total number of accidents is with the total within in Year-Month combination)
plot_month <- ggplot(dt_temporal_month |> mutate(Month = as.factor(Month))) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Month)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Month),
                      alpha = 0.4, fill = "cornflowerblue") +
  theme_minimal() +
  labs(subtitle = "By month")

# Distribution of total number of accidents by Day of week (the total number of accidents is with the total within in Year-Month combination)
plot_weekday <- ggplot(dt_temporal_month) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Week_day)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Week_day),
                      alpha = 0.4, fill = "cornflowerblue") +
  theme_minimal() +
  labs(subtitle = "By weekday")

```

```{r}

# Distribution of total number of accidents by Hour (the total number of accidents is with the total within in Year-Month combination)

plot_hours <- ggplot(dt_temporal_hour |> mutate(Crash_Hour = as.factor(Crash_Hour))) +
  geom_boxplot(mapping = aes(x = total_accidents, y = Crash_Hour)) +
  geom_density_ridges(mapping = aes(x = total_accidents, y = Crash_Hour),
                      alpha = 0.4, fill = "cornflowerblue") +
  theme_minimal()
# combined_plots <- plot_month + plot_weekday + plot_hours

# Combine the plots side by side with one common title
combined_plots <- plot_month + plot_weekday +
  plot_layout(ncol = 1, heights = c(2, 1)) +
  plot_annotation(title = "Distribution of total number of accidents")

# Print the combined plots
print(combined_plots)

plot_hours + labs(title = "Distribution of total number of accidents by day-hour")
```


+ By combining histograms and density plots, we gain valuable insights into the distribution of total accidents aggregated by months per year, examining variations across different months, weekdays, and day-hours


+ **Number of accidents per month**:
Analyzing the density plots reveals a similar distribution in the total number of accidents across different months. However, delving into boxplots exposes distinct variances; for instance, the interquartile range (IQR) for January is significantly wider than that of February.


+ **Number of accidents per weekday**:
The density plots unveil noticeable differences in the distribution of total accidents between weekends and weekdays, providing insights into the varying patterns throughout the week. This difference may be explained by the fact that people tends to use less their car during weekend.

+ **Number of accidents per Hour in day**:
Exploring the density plots illustrates significant disparities in the distribution of total accidents across different times of the day. During the night time, there is a lower disparity in the number of accidents, making predictions more manageable. On the contrary, daytime accidents exhibit higher disparity, suggesting that factors beyond the time of day play a significant role. Identifying predictors, such as holidays or specific events, could be useful in preventing unnecessary accidents. Notably, it confirms the increase in accidents during the middle of the day, aligning with the expected higher traffic volumes during those hours.


## Part 2 - Hit/run Analyis
In this part we address the pressing issue of **hit-and-run accidents**. We examine correlation between various features and the "Hit-Run" column. Hit and Run accidents involve perpetrators who attempt to flee the scene without taking responsibility for the consequences of their actions. Identifying patterns in the behavior of these accidents could assist the police in reducing the proportion of such incidents. This could help victims of accidents to be compensated for the damage.

```{r, message=FALSE}
dt_temporal_Year_month_hit_run <- dt_temporal |> group_by(Year, Month, first_day_of_month, Week_day, Hit_Run) |> summarise(total_accidents = n())

dt_temporal_Year_month_hit_run <- dt_temporal |> group_by(Year, Month, first_day_of_month, Week_day, Hit_Run) |> summarise(total_accidents = n())

```


### Is it more likely to Hit and Run in a specific Month / Week day / Hour?

```{r, fig.width=10}
# Filter out NA values for Hit_Run
filtered_data <- dt_temporal %>%
  filter(!is.na(Hit_Run))

# Abbreviate the Month and Weekday names
month_labels <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
weekday_labels <- c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")

# Divide the crash hour into groups
filtered_data$Crash_Hour_Group <- cut(filtered_data$Crash_Hour,
  breaks = c(0, 4, 8, 12, 16, 20, 24),
  labels = c("0-4", "4-8", "8-12", "12-16", "16-20", "20-24"),
  include.lowest = TRUE)

plot_month <- ggplot(filtered_data) +

  geom_bar(aes(x = Month, fill = Hit_Run), position = "fill", color = "grey40") +
  scale_fill_manual(values = c("No" = "grey84", "Yes" = "lightgreen")) +
  labs(title = "Proportion of Hit-Run Accidents",
       subtitle = "Per Month of Year",
       x = "Month",
       y = "Proportion") +
  scale_x_discrete(labels = month_labels) +  # Abbreviate Month names
  theme_minimal() +
  theme(legend.position = "none")  # Remove the legend

# Create a bar plot for Weekday
plot_weekday <- ggplot(filtered_data) +
  geom_bar(aes(x = Week_day, fill = Hit_Run), position = "fill", color = "grey40") +
  scale_fill_manual(values = c("No" = "grey84", "Yes" = "lightgreen")) +
  labs(subtitle = "Per Weekday",
       x = "Weekday") +
  scale_x_discrete(labels = weekday_labels) +  # Abbreviate Weekday names
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank())  # Remove y-axis components



plot_hours <- ggplot(filtered_data) +
  geom_bar(aes(x = Crash_Hour_Group, fill = Hit_Run), position = "fill", color = "grey40") +
  labs(subtitle = 'Per Hour',
       x = "Crash Hour", y = NULL) +
  scale_fill_manual(values = c("No" = "grey84", "Yes" = "lightgreen")) +
  theme_minimal() +
  theme(legend.position = "none", axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank())  # Remove y-axis components



# Arrange the two plots side by side
combined_plot <- plot_month + plot_weekday + plot_hours +  theme(legend.position = "bottom") 

# Print the combined plot
print(combined_plot)
```


+ There doesn't appear to be a correlation between the month and Hit-Run incidents; in other words, there isn't a particular month with a higher likelihood of a Hit-Run accident.

+ However, we observe a higher proportion of Hit-Run incidents during weekends (Saturday and Sunday) compared to the proportions on other weekdays. Knowing from one of the previous visualization that in average less accidents occur during weekends, it reinforces the idea that the increase amount of Hit and Run during the weekend is a significant trend that should be explored rather than mere coincidence.

+ Concerning the Hit-Run proportion per hour, we can observe there is a higher proportion of Hit-Run accidents during late hours. Furthermore, there seems to be a consistent "linear trend" in Hit-Run incidents as the day unfolds.


### Analyzing First_Harmful_Event with respect to Hit_Run

```{r, fig.height=7, fig.width=12}
#count(dt_temporal, First_Harmful_Event) |> arrange(desc(n))

### taking only the 7 top categories in  First_Harmful_Event
df_for_harmful_event <- dt_temporal %>%
  filter(!is.na(First_Harmful_Event)) %>%  # Remove NA values
  mutate(
    First_Harmful_Event = tolower(First_Harmful_Event),
    First_Harmful_Event = factor(First_Harmful_Event) %>% fct_lump(n = 7, other_level = "Other"))

###Mosaic plot 1:
mosaicplot(table(factor(df_for_harmful_event$First_Harmful_Event), df_for_harmful_event$Hit_Run), main= "Mosaic plot for Hit Run vs First Harmful Event",
           color = c(rgb(0.5,0.5,0.5, alpha = 0.5), rgb(0,1,0, alpha = 0.5)), 
           las = 1)  # Rotate labels by 90 degrees

#count(df_for_harmful_event, Hit_Run, First_Harmful_Event)

```

+ We can see that the first harmful event has a great connection / correlation to the Hit-Run variable --> there are great variations between the proportion of Hit-Run vs. Non Hit-Run accidents given the different `First_Harmful_Event` categories.

+ Note that for "Parked-Vehicle" the proportion of Hit-Run is 0.45 which is more than twice as big as the overall Hit-Run proportion (0.18) 

```{r}
# Calculate the proportion of Hit/Run in the dataset

df_for_harmful_event |> count(Hit_Run) |> mutate("prop" = n/nrow(dt_temporal))
a <- df_for_harmful_event |> filter(grepl(c("Parked"), First_Harmful_Event, ignore.case = T)) |> count(Hit_Run, First_Harmful_Event) 
a|> mutate("prop" = n/sum(a$n)) 

```

+ So we observe the beginning of a pattern about Hit and Run incidents that we will continue to explore.

```{r}
# Create a data set of interest
dt_responsible <- data_crash[,c("Hit_Run","NonTraffic","ACRS_Report_Type")]


# Rename the element in "ACRS_Report_Type"
dt_responsible <- dt_responsible %>%
   mutate(ACRS_Report_Type = recode(ACRS_Report_Type,
    "Injury Crash" ="Injury",
    "Fatal Crash" = "Fatal",
    "Property Damage Crash" = "Property Damage")) %>%
    filter(ACRS_Report_Type != "Fatal")

# Rename the element in "ACRS_Report_Type"
dt_responsible <- dt_responsible %>%
   mutate(Traffic = recode(NonTraffic,
    "Yes" ="No",
    "No" = "Yes"))%>%
  select(-NonTraffic)

#redav::plot_missing(dt_responsible) # We see that more than 80% of the rows does not have Na so I will drop all the Na

dt_responsible <- dt_responsible %>%
  na.omit() 

vcd:: mosaic(Hit_Run ~ ACRS_Report_Type + Traffic ,
 data = dt_responsible,
 direction = c("v", "v" ,"h"),
 highlighting_fill = c("grey84", "lightgreen"))
```

+ This mosaic plots highlights two main trends about Hit and Run accidents. First, the **proportion of hit and run is higher when nobody was injured**. This correlates with the previous results about the parked vehicle in the `first harmful event` column. More people tend to flee when there is just material damage.

 + The second insight is that **drivers tend to flee more when there is no traffic**. Two conclusions can be made: either drivers feel less pressure to stop and report the damage done when there is no traffic or maybe it is simply easier to leave the incident location when there is no traffic. 
  
 + These two insights help us understand better the driver's behavior in the case of Hit and Run. However, this does not help us prevent these type of accident. So, in the following part we explore the correlation between the characteristics of the roads and the number of Hit and Run accidents in order to give meaningful advice for reducing the proportion of these accidents.

### Study of the influence of the characteristics of the roads on the number of accident and Hit/Run

```{r}
## Create 2 new datasets to explore different Categorical values
dt_lane <- data_crash[,c("Road_Division", "Junction", "Road_Alignment" ,"Traffic_Control","Road_Name","Cross_Street_Name","Number_of_Lanes","Hit_Run","Longitude",'Latitude')]

#Rename the column in Road_type and get rid of the Na and the unknown values
dt_lane <- dt_lane %>%
  mutate(Road_Division = recode(Road_Division,
        "TWO-WAY, NOT DIVIDED WITH A CONTINUOUS LEFT TURN" = "2-way, not divided",
        "TWO-WAY, NOT DIVIDED" = "2-way, not divided",
        "TWO-WAY, DIVIDED, POSITIVE MEDIAN BARRIER" = '2-way, divided',
        "TWO-WAY, DIVIDED, UNPROTECTED PAINTED MIN 4 FEET" = '2-way, divided',
        "ONE-WAY TRAFFICWAY" = '1-way',
        "OTHER" = 'Other')) %>%
  filter(Road_Division != 'UNKNOWN') %>%
  filter(Road_Division != 'Other') %>%
  na.omit()

# #Change the column Number of Lanes to remove the lanes with more than 6 lanes
# dt_lane <- dt_lane %>%
#   filter(Number_of_Lanes < 7) %>%
#   filter(Number_of_Lanes != 0)
#   
# # Change the order of factor 
# dt_lane$Road_Division <- factor(dt_lane$Road_Division, levels = c("1-way", "2-way, not divided", "2-way, divided", 'Other'))
# 
# 
# ggplot(dt_lane, aes(y=Road_Division))+
#   geom_bar() +
#   facet_grid(Number_of_Lanes~.)+
#   #theme(axis.text.x = element_text(angle = 45, hjust = 1))+
#   labs(title ='Facet by number of Lanes' )
# <u>Comment :</u> One can see that most of the accidents that happends on 3 lanes road are 2-way and divided (most likely highway). 

#Traffic Control

dt_lane <- dt_lane %>%
   mutate(Traffic_Control = recode(Traffic_Control,
        "FLASHING TRAFFIC SIGNAL" = "Traffic Light",
        "TRAFFIC SIGNAL" = "Traffic Light",
        "NO CONTROLS" = 'No Sign',
        "RAILWAY CROSSING DEVICE	" = 'Warning Sign',
        "WARNING SIGN" = 'Warning Sign',
        "SCHOOL ZONE SIGN DEVICE" = 'Warning Sign',
        "YIELD SIGN" = 'Warning Sign',
        "STOP SIGN" = 'Stop Sign',
        .default  = 'Other')) %>%
  filter(!is.na(Traffic_Control))

lane_freq <- dt_lane %>%
  count(Traffic_Control, name = "Frequency_control")
dt_lane <- left_join(lane_freq, dt_lane, by = "Traffic_Control")
  
# ggplot(dt_lane, aes(x = reorder(Traffic_Control, -Frequency_control))) +
#   geom_bar() +
#   labs(title = "Bar Plot of Junction Types with Count", x = "Junction Type", y = "Count") +
#   theme_minimal()  # Adjust the theme if needed
```


#### Insight about accidents around intersection

First, let's observe the typical situation in which accidents occur :

```{r}
dt_lane <- dt_lane %>%
  mutate(Junction = recode(Junction,
        "INTERSECTION" = "Intersection",
        "INTERSECTION RELATED" = "Intersection",
        "NON INTERSECTION" = 'Non Intersection',
        "OTHER DRIVEWAY" = 'Driveway',
        "COMMERCIAL DRIVEWAY" = 'Driveway',
        "ALLEY" = 'Driveway',
        "CROSSOVER RELATED" = "Crossover",
        "INTERCHANGE RELATED" = "Interchange",
        "RESIDENTIAL DRIVEWAY" = 'Driveway',
        "RAILWAY GRADE CROSSING"= 'Other',
        "OTHER" = 'Other')) %>%
  filter(Junction != 'UNKNOWN') %>%
  filter(Junction != 'Other') %>%
  na.omit() 

lane_freq <- dt_lane %>%
  count(Junction, name = "Frequency_junc")
dt_lane_freq <- left_join(lane_freq, dt_lane, by = "Junction")

ggplot(dt_lane_freq, aes(x = reorder(Junction, -Frequency_junc))) +
  geom_bar(aes(fill = Traffic_Control)) +
  labs(title = "Relation between Junction Types and Traffic Control sign", x = "Junction Type", y = "Count", fill = "Signalisation for Traffic") +
  scale_fill_viridis_d() +
  theme_minimal()  
```

+ We can observe that **most of the car accidents happen at an intersection**. Further, half of the crashes at these intersection have **traffic lights**. This highlights an important issue: traffic light are not sufficient to mitigate the risk of car accident. The data set provides the name of the intersection so we can explore the proportion of intersections with traffic light and compare that to the proportion of accidents happening at an intersection with traffic light. In the following plot we compare these two proportions.


```{r}
# Calculate the total number of unique intersection
total_combinations_intersec <- dt_lane_freq %>%
  filter(Junction == "Intersection") %>%
  summarise(total_combinations_count = n_distinct(paste(Cross_Street_Name, Road_Name, sep = "_")))

# Calculate the number of unique intersection with a traffic light
with_traffic_light <- dt_lane_freq %>%
  filter(Junction == "Intersection") %>%
  filter(Traffic_Control == "Traffic Light") %>%
  summarise(with_traffic_light_count = n_distinct(paste(Cross_Street_Name, Road_Name, sep = "_")))

# Calculate the proportion
proportion_with_traffic_light <- with_traffic_light$with_traffic_light_count / total_combinations_intersec$total_combinations_count

#print(paste("Proportion of Intersection with Traffic Light: ", proportion_with_traffic_light))


ggplot(dt_lane_freq %>% filter(Junction == 'Intersection'), aes(x = reorder(Junction, -Frequency_junc), fill = Traffic_Control)) +
  geom_bar(position = "fill", width = 0.6) +
  labs(
    title = "Proportion of accident on intersection depending on the signalisation",
    subtitle = paste0("Knowing that ", round(proportion_with_traffic_light * 100,1), "% of the intersection has a traffic light"),
    x = "Junction Type",
    y = "Proportion",
    fill = "Signalisation for Traffic"
  ) +
  scale_fill_viridis_d() +
  theme_minimal()+
  coord_flip()+
   theme(aspect.ratio = 0.4)


```

Despite not having information regarding the portion of cars crossing intersection with traffic light vs car crossing intersection without traffic light, this histogram indicates that traffic light are not efficient enough for reducing car accidents. Indeed, even though less than 40% of the intersection in the county have traffic lights, overall more than 60% of the accidents occur at these intersection. A possible reason is that drivers rely too much on the traffic light and do not proceed to do the safety check when crossing an intersection. 
<u>NB:</u> In this study we focus only on the number of accidents and not on the fluidity of the traffic for instance. Needless to say that reducing the number of accidents cannot be the only factor to consider when designing traffic sign on the roads. 


#### Alluvial plot to understand Hit/Run pattern

```{r}

dt_lane1 <- dt_lane[,c('Road_Division', 'Junction', 'Traffic_Control','Road_Name','Hit_Run')]

n_threshold = 100 
dt_lane1 <- dt_lane1 %>%
  group_by(Road_Division, Junction, Traffic_Control) %>%
  mutate(Frequency = n()) %>%
  ungroup() %>%
  filter(Frequency >= n_threshold) %>%
  distinct(Road_Division, Junction, Traffic_Control, .keep_all = TRUE)

# Map_pt <- dt_lane1$Road_Name
# Map_pt

junction_order <- c("Crossover", "Intersection", "Driveway","Non Intersection", "Interchange")

# Reorder the Junction variable in the dataset
dt_lane1 <- dt_lane1 %>%
  mutate(Junction = factor(Junction, levels = junction_order))

# Plot the alluvial diagram

ggplot(data = dt_lane1,
       aes(axis1 = Road_Division, axis2 = Traffic_Control, axis3 = Junction, axis4= Hit_Run, y = Frequency)) +
  geom_alluvium(aes(fill = Hit_Run)) +
  geom_stratum() +
  geom_text(stat = "stratum",
            aes(label = after_stat(stratum))) +
  #scale_x_discrete(limits = c("Road Division", "Traffic Signal", "Junction type"),
                   #expand = c(0.15, 0.05, 0.05)) +
  scale_fill_brewer(type = "seq", palette = "PuRd") +
  labs(title = 'Alluvial plot combining characteristics about the crash location and the Hit/Run situation', fill= 'Hit/Run')+
  theme_void()
```

To conclude this part about Hit and Run accidents we will analyze this alluvial plot. It assists us in visualizing the most common scenarios leading to Hit and Run accidents. Indeed, the majority of these accidents occur on **undivided two-way roads at non-intersections with no traffic controls**. This visible pattern in the scenario of Hit and Run can be used to understand how the police could reduce this type of accident. Without inferring causation from these correlation results, one might consider that the absence of traffic signs could potentially contribute to a sense of impunity among certain drivers, leading them to flee more frequently, assuming they are not being observed. For a more in-depth examination of this pattern, we would suggest law enforcement to conduct a targeted study focusing on roads without traffic signs to determine whether their presence has an impact on the occurrence of hit and run accidents. It's important to note that these findings are purely correlational; other factors, such as accident severity, may play a role. If our dataset included a severity column, or even number of casualties/injured/property damage assessment we could have explored this aspect further.


## Part 3 - Spatial Representation

We employ **geographical**, or **spatial**, data to explore the relationship between accident density and geographical attributes. Specifically, we aim to identify roads with the highest concentration of accidents and analyze common attributes among them. 


```{r, message= FALSE, warning= FALSE}
## We are removing the data points which are not in the county

# 1st step : get the coordinate of the Montgomery county using a public data
montgomery_geojson_url <- 'https://raw.githubusercontent.com/johan/world.geo.json/master/countries/USA/MD/Montgomery.geo.json'
montgomery_county <- st_read(montgomery_geojson_url)

```
<u> **Heatmap of the number of Hit and Run accidents** </u>
```{r}
# 2nd step : Filter the data to keep only the Hit/Run incidents
hit_run_pos <- data_crash %>%
  filter(Hit_Run == 'Yes')
  
# Create a new dataset with only the coordinate of points inisde the county
coordinate_Montgomery <- hit_run_pos %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_intersection(montgomery_county) %>%
  st_coordinates() %>%
  as.data.frame()


leaflet(coordinate_Montgomery) %>%
  addTiles() %>% 
  addHeatmap(
  lat = ~Y,
  lng = ~X,
  blur = 15,
  radius = 10) 

# dt_without <- dt_lane %>%
#   filter(Hit_Run != 'Yes')
# 
# # Create a new dataset with only the coordinate of points inisde the county
# coordinate_Montgomery2 <- dt_without %>%
#   st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
#   st_intersection(montgomery_county) %>%
#   st_coordinates() %>%
#   as.data.frame() 
#   
# 
# leaflet(coordinate_Montgomery2) %>%
#   addTiles() %>% 
#   addHeatmap(
#   lat = ~Y,
#   lng = ~X,
#   blur = 15,
#   radius = 10) 
```

+ First, we can see that the density of Hit and Run accidents is higher in the southern part of the county when compared to the northern region. This follows the urban area characteristic of the county. The denser city area tends to have more Hit and Run accidents.

+ One key element that can be taken from that interactive map is that parking spots are places with high density of Hit and Run accidents. This correlates with one of our previous mosaic plot that displayed the 'First_Harmful_Event' column. We saw there that the "Parked-Vehicle" is the category with the highest proportion of Hit and Run.

+ Moreover, it is visible that intersections are locations with higher density of Hit and Run accidents. Overall, this heat map helps us visualize the patterns we have discovered earlier, it is clear that there is almost no Hit and Run accidents on highways like the 15A. 

<u>NB:</u> We also explored the same visualization for only the non Hit and Run accidents and we could see indeed that density of accidents is more uniform than for Hit and Run accident across the county and there are less accudents in parking spots.

```{r}
dt_lane2 <- dt_lane %>%
  group_by(Road_Name) %>%
  mutate(Frequency_road = n()) %>%
  ungroup() %>%
  #filter(Frequency >= n_threshold) %>%
  distinct(Road_Name, .keep_all = TRUE) %>%
  filter(Hit_Run != 'Yes')

top_10_roads <- dt_lane2 %>%
  arrange(desc(Frequency_road)) %>%  # Arrange by Frequency in descending order
  slice_head(n = 10) %>%       # Select the top 10 rows
  select(Road_Name,Frequency_road) %>%
  as.list()

dt_top10 <- dt_lane %>%
  filter(Road_Name %in% top10)

top10 <- top_10_roads$Road_Name

dt_without <- dt_lane %>%
  filter(Hit_Run != 'Yes')

# Create a new dataset with only the coordinate of points inisde the county
coordinate_Montgomery2 <- dt_without %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_intersection(montgomery_county) %>%
  st_coordinates() %>%
  as.data.frame() 
  

leaflet(coordinate_Montgomery2) %>%
  addTiles() %>% 
  addHeatmap(
  lat = ~Y,
  lng = ~X,
  blur = 15,
  radius = 10) 
```


---------------------------------------------------------------------------

## Overall findings from plots we didn't include in this project:

Other than the plots we presented in this section, we created dozens more visualizations that were less informative thus excluded from the final report. However, we would like to highlight some of the findings and insights we derived from them.

```{r}
dt_temporal <- dt_temporal %>%
  filter(!Weather %in% c("OTHER", "UNKNOWN")) %>%
  filter(!is.na(Weather))

dt_temporal <- dt_temporal %>%
  mutate(Weather = if_else(Weather %in% c("SNOW", "SLEET","BLOWING SNOW"), "SNOW", Weather)) %>%
  mutate(Weather = if_else(Weather %in% c("SEVERE WINDS", "WINTRY MIX", "BLOWING SAND, SOIL, DIRT"), "WIND", Weather))%>%
  mutate(Condition = if_else(Weather %in% c("CLEAR","CLOUDY"),"Good","Bad"))

# color_scale <- c("RAINING" = "slateblue", "SNOW" = "whitesmoke", "CLOUDY" = "gray", "FOGGY" ="gray27", "WIND"="seagreen4", "CLEAR" ="skyblue")
# 
# dt_temporal$Weather <- reorder(dt_temporal$Weather, X= as.numeric(factor(dt_temporal$Weather,levels = c('CLEAR','CLOUDY','FOGGY','WIND','SNOW','RAINING'))))
# 
# ggplot(dt_temporal, aes(x = Condition, fill = Weather)) +
#   geom_bar() +
#   scale_fill_manual(values = color_scale)
```


+ **Weather data**: 
We define an accident that occurred with "good" weather conditions as an accident that the value in the column `Weather` was "CLEAR" or "CLOUDY". The other condition types are classified as "Bad".
We analyzed the number of accidents in "Good" versus "Bad" weather conditions and found there are more accidents on days with "good" weather condition. 
The issue with that analysis is we don't have the overall proportion of "good" vs. "bad" days. Our assumption is there are more "good" than "bad" days, and therefore, the fact there are more accidents on "good" days, doesn't really mean anything.

+ We checked and there doesn't seem to be a correlation between the `Weather` and the `Hit_Run`

```{r}
# df_mosaic_by_weather <- dt_temporal |> group_by(Weather, Hit_Run) |> summarise(Freq = n())
# 
# ###Mosaic plot 1:
# mosaicplot(table(dt_temporal$Weather, dt_temporal$Hit_Run), main= "Mosaic plot for Hit Run vs First Harmful Event", color = c('tomato', 'darkgreen'), las = 2)  # Rotate labels by 90 degrees
```



```{r}
# ### Speaking about Roads, where are we ?
# 
# dt_lane2 <- dt_lane %>%
#   group_by(Road_Name) %>%
#   mutate(Frequency_road = n()) %>%
#   ungroup() %>%
#   #filter(Frequency >= n_threshold) %>%
#   distinct(Road_Name, .keep_all = TRUE)
# 
# top_10_roads <- dt_lane2 %>%
#   arrange(desc(Frequency_road)) %>%  # Arrange by Frequency in descending order
#   slice_head(n = 10) %>%       # Select the top 10 rows
#   select(Road_Name,Frequency_road) %>%
#   as.list()
# 
# top10 <- top_10_roads$Road_Name
# top10
```

+ Time-plot displaying the total number of accidents trend over the years faceted by weekdays:

  - In the faceted line graph, a consistent trend is apparent in the number of accidents per weekday, suggesting a similar pattern across the week. However, the magnitude of accidents varies, with fewer incidents occurring on weekends, which aligns with expectations. Notably, the middle of the week appears to experience a higher frequency of accidents.

  - Furthermore, an examination of the "black dots," representing each year's month with the highest number of accidents, provides additional insights. Comparing these dots across different weekdays reveals distinctions, and an intriguing observation emerges when connecting these dots. If we were to draw a line connecting each black dot, a trend similar to the loess blue line trend in the plot becomes evident, indicating a potential overarching pattern in the occurrence of maximum accidents over the years.



```{r}
## Filter the highest point in each Year
# highest_points <- dt_temporal_Year_month %>%
#   group_by(Year, Week_day) %>%
#   slice_max(order_by = total_accidents)
# 
# ggplot(dt_temporal_Year_month, aes(x=first_day_of_month, y=total_accidents)) + 
#   geom_line() + 
#   stat_smooth(method = "loess", span=0.63, col = "blue", size = 1, se = FALSE) +  # Add a moving average line
#   geom_point(data = highest_points, col = "black", size = 1.4) +  # Add points only for Jan
#   facet_grid(~Week_day) +
#   labs(title = "line plot of total accidents faceted by weekday",
#        subtitle = "The black dots present for each year the month with \nthe highest number of accidents")

```

+ **Influence of Substances**:

We also wanted to explore the affect of taking substance on the the number of accidents and Hit and Run. In most of the car accidents no substance were detected, the second highest number of accidents was made under the effect of alcohol. Then, the next category is called 'unknown'. At first we thought it was related to accidents in which testing the substance was forgotten however by looking at the correlation with Hit/Run we surprisingly saw high proportion of Hit and Run for this category. So, despite having more information about this category we assumed that in most of these accidents the driver was not found leading to a lack of information about whether or not they consumed any substance (Or when the police caught the driver, it was too late to test for those substances).
Furthermore, there was no significant difference in proportions among the various substances when examining hit and run accidents.
Similarly we didn't see any important trend when looking at who is at fault in the accident. The large majority of the time, the driver is at fault. However, there is a slight decrease of accident for which the non driver is not at fault when the driver took substance ; the proportion drop from 10% to 2% but it is not worth interpreting it further more. 

```{r}
dt_responsible <- data_crash[,c("At_Fault","Driver_Substance_Abuse")]
# Rename the elements in "Driver_Substance_Abuse" and filter the Na
dt_responsible <- dt_responsible %>%
  mutate(Driver_Substance_Abuse = str_extract(Driver_Substance_Abuse, "^[^,]+")) %>%
  mutate(Driver_Substance_Abuse = recode(Driver_Substance_Abuse,
    "ALCOHOL CONTRIBUTED" ="alcohol",
    "ALCOHOL PRESENT" = "alcohol",
    "COMBINATION CONTRIBUTED" = "combined substance",
    "COMBINED SUBSTANCE PRESENT" = "combined substance",
    "ILLEGAL DRUG CONTRIBUTED" = "illegal drug",
    "ILLEGAL DRUG PRESENT" = "illegal drug",
    "MEDICATION CONTRIBUTED" = "under medication",
    "MEDICATION PRESENT" = "under medication",
    "UNKNOWN" = 'unknown',
    "OTHER" = 'unknown',
    "NONE DETECTED" = 'none detected'
  )) %>%
  filter(Driver_Substance_Abuse != "N/A")

dt_responsible <- dt_responsible %>%
  #filter(Driver_Substance_Abuse != 'none detected')  %>% # remove the none detected because they are too much
  #filter(Driver_Substance_Abuse != 'alcohol') %>%
  filter(Driver_Substance_Abuse != 'unknown')

responsible_freq <- dt_responsible %>%
  count(Driver_Substance_Abuse, name = "Frequency_drug")
dt_responsible <- left_join(responsible_freq, dt_responsible, by = "Driver_Substance_Abuse")
  
# ggplot(dt_responsible, aes(x = reorder(Driver_Substance_Abuse, -Frequency_drug))) +
#   geom_bar() +
#   labs(title = "Bar Plot of Junction Types with Count", x = "Junction Type", y = "Count") +
#   theme_minimal()  # Adjust the theme if needed
# 
# vcd::mosaic(At_Fault ~ Driver_Substance_Abuse,
#              data = dt_responsible,
#   direction = c("v", "h" ))
```


